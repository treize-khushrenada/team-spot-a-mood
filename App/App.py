import streamlit as st
from st_aggrid import AgGrid, GridUpdateMode
from st_aggrid.grid_options_builder import GridOptionsBuilder

import joblib
import pickle
import os

import pandas as pd
import numpy as np
import altair as alt

from PIL import Image
from sentence_transformers import SentenceTransformer, util

from sklearn.decomposition import PCA

import songs_rec
path = os.path.dirname(__file__)
st.set_page_config(page_title="Spotamood - App")

# embeddings for test set - generated by pretrained model
@st.cache(show_spinner=False)
def load_embeddings():
    with open(path + '/pickle_objects/embeddings.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

#TODO: embeddings for test set - generated by fine-tuned model
@st.cache(show_spinner=False)
def load_embeddings_ft():
    with open(path + '/pickle_objects/embeddings_test.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_arr_song_idx():
    with open(path + '/pickle_objects/arr_song_idx_test.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_arr_lyrics_idx():
    with open(path + '/pickle_objects/arr_lyrics_idx_test.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_embeddings_clip():
    with open(path + '/pickle_objects/embeddings_clip.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_arr_song_idx_clip():
    with open(path + '/pickle_objects/arr_song_idx_clip.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_arr_lyrics_idx_clip():
    with open(path + '/pickle_objects/arr_lyrics_idx_clip.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj

@st.cache(show_spinner=False)
def load_sample_artists_set():
    with open(path + '/pickle_objects/song_lyrics_set_test.pickle', 'rb') as f:
        obj = pickle.load(f)
    return obj[0]

@st.cache(show_spinner=False)
def load_sampling_cluster():
    with open(path + '/pickle_objects/sampling_cluster.pickle', 'rb') as f:
        df = pickle.load(f)
    return df

@st.cache(show_spinner=False)
def load_sampling_cluster_ft():
    with open(path + '/pickle_objects/sampling_cluster_test.pickle', 'rb') as f:
        df = pickle.load(f)
    return df

@st.cache(show_spinner=False)
def load_pca():
    with open(path + '/pickle_objects/pca_model.pickle', 'rb') as f:
        pca = pickle.load(f)
    return pca  

@st.cache(show_spinner=False)
def load_pca_ft():
    with open(path + '/pickle_objects/pca_model_test.pickle', 'rb') as f:
        pca = pickle.load(f)
    return pca

def load_model(model_name = "all-distilroberta-v1"):
    model = SentenceTransformer(model_name)

    return model
def load_model_ft(model_name = path + "/pickle_objects/ft_model_full_annotations/"):
    model = SentenceTransformer(model_name)
    
    return model

#load default model and empty dataframe
model = load_model()

df_results = pd.DataFrame()

# Sidebar
st.sidebar.header('About This App')
st.sidebar.markdown("Use this tool to search for specific lyrics lines that match the meaning of your text or image input!\
                    Simply hit enter after you enter the text, or upload an image(an experimental function) to get started.<br><br>\
                    Disclaimer: This tool is not developed to encourage any self-harming and unethical behaviors.\
                    If you feel you are struggling, please seek professional help.<br><br>\
                    Our library contains information of 1000 'billboard top 100' songs at the moment.\
                    You can also refine the search scope by specifying a range of happiness level with the slider tool.<br><br>\
                    Recommendation is performed by a semantic textual similarity algorithm based on word embeddings generated by pretrained and fine-tuned BERT models.\
                    Please refer to other pages for more details.", unsafe_allow_html=True)
#TODO: Broader impacts
# Main body
## Project title 
st.title('Spot-A-Mood Playlist Recommendation')

## Text query
text_input = st.text_input("What's on your mind? (Press Enter to get results)", placeholder="What's on your mind?", key="txt")

model_txt_selection = st.radio("Choose a model: ",('Pretrained(all-distilroberta-v1)', 'Fine-tuned'))

## valence_range
valence_range = st.slider('Choose your happiness level',0, 10, (0, 10), key="txt_mood")
valence_min = valence_range[0]/10
valence_max = valence_range[1]/10

def load_results_img(query):
    embeddings_clip = load_embeddings_clip()
    arr_song_idx_clip = load_arr_song_idx_clip()
    arr_lyrics_idx_clip = load_arr_lyrics_idx_clip()
    sample_artists_set = load_sample_artists_set()
    results = songs_rec.main(query_img, embeddings_clip, sample_artists_set, arr_lyrics_idx_clip, arr_song_idx_clip,[valence_min_img, valence_max_img], model_img)
    df_img = pd.DataFrame(results)
    df_results_img = df_img[['song title', 'artist', 'song_score']]
    return df_img, df_results_img


def load_results_txt(query):
    embeddings = load_embeddings()
    arr_song_idx = load_arr_song_idx()
    arr_lyrics_idx = load_arr_lyrics_idx()
    sample_artists_set = load_sample_artists_set()
    results = songs_rec.main(query, embeddings, sample_artists_set, arr_lyrics_idx, arr_song_idx, [valence_min, valence_max], model)
    df = pd.DataFrame(results)
    df_results = df[['song title', 'artist', 'song_score']]
    return df, df_results

def load_results_txt_ft(query):
    embeddings = load_embeddings_ft()
    arr_song_idx = load_arr_song_idx()
    arr_lyrics_idx = load_arr_lyrics_idx()
    sample_artists_set = load_sample_artists_set()
    results = songs_rec.main(query, embeddings, sample_artists_set, arr_lyrics_idx, arr_song_idx, [valence_min, valence_max], model)
    df = pd.DataFrame(results)
    df_results = df[['song title', 'artist', 'song_score']]
    return df, df_results

def query_pca(query, model):
    input_emb = model.encode(query, convert_to_tensor=True)
    input_emb = input_emb.reshape(1,-1)
    pca = load_pca()
    pca_df = pd.DataFrame(pca.transform(input_emb), columns=['component1', 'component2'])
    pca_df['query'] = query
    return pca_df

def query_pca_ft(query, model):
    input_emb = model.encode(query, convert_to_tensor=True)
    input_emb = input_emb.reshape(1,-1)
    pca = load_pca_ft()
    pca_df = pd.DataFrame(pca.transform(input_emb), columns=['component1', 'component2'])
    pca_df['query'] = query
    return pca_df

    #Visuals - text search results
if text_input not in ["", None]:
    query =  text_input
    ## Reminder
    st.markdown('It might take a few moments to generate results')
    
    with st.spinner('Generating results...'):
        
        if model_txt_selection == 'Pretrained(all-distilroberta-v1)':
            df, df_results = load_results_txt(query)
            # for cluster visualization
            sampling_df = load_sampling_cluster()
            query_df = query_pca(query, model)
        
        if model_txt_selection == 'Fine-tuned':
            model = load_model_ft()
            df, df_results = load_results_txt_ft(query)
            # for cluster visualization
            sampling_df = load_sampling_cluster_ft()
            query_df = query_pca_ft(query, model)

    # Songs recommendation list
    st.header('Results')
    with st.container():
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader('Songs:')

            gd = GridOptionsBuilder.from_dataframe(df_results)
            gd.configure_selection(selection_mode='single', pre_selected_rows=[0], use_checkbox=False)
            gridoptions = gd.build()

            grid_table = AgGrid(df_results, height=400, width=100, gridOptions=gridoptions, fit_columns_on_grid_load=True,  reload_data = False, theme = 'streamlit', data_return_mode='AS_INPUT', update_mode='MODEL_CHANGED')
        with col2:
            st.subheader('Lyrics:')
            st.write("Credits: Genius Community")
            selected_row = grid_table["selected_rows"]
            if selected_row is not None:
                try:
                    selected_row_index = selected_row[0]['_selectedRowNodeInfo']['nodeRowIndex']
                    tuple_lyrics_results = df['lyrics_scores'].iloc[int(selected_row_index)]
                    for result in tuple_lyrics_results:
                        lyrics = result[0]
                        lyrics_score = result[1]
                        lyrics_result = '<p style="font-size: {0}px;">{1} ({2})</p>'.format(str(48*float(lyrics_score)), lyrics, round(lyrics_score,3))
                        st.markdown(lyrics_result, unsafe_allow_html=True)
                except:

                    pass

    # Chart Display Cluster and Query Results
    st.subheader('Embeddings Clusters:')

    # encode charts
    embeddings_cluster_chart = alt.Chart(sampling_df).mark_circle().encode(
        x=alt.X('component1:Q'),
        y=alt.Y('component2:Q'),
        color=alt.Color('cluster:O', scale=alt.Scale(scheme='tableau10')),
        tooltip=['lyrics', 'cluster']
    )
    # encode query
    query_chart = alt.Chart(query_df).mark_square(size=80, color='red').encode(
        x=alt.X('component1:Q'),
        y=alt.Y('component2:Q'),
        tooltip='query'
    )
    # display 2 charts layer on each other
    chart = (embeddings_cluster_chart+query_chart).interactive()
    st.altair_chart(chart, use_container_width=True)

## Image upload
#with st.form("input_form", clear_on_submit=True):
image_input = st.file_uploader("Or upload an image (experimental)", type=['.png','jpg'], accept_multiple_files=False, key="img")
## valence_range
valence_range_img = st.slider('Choose your happiness level',0, 10, (0, 10), key="img_mood")
valence_min_img = valence_range_img[0]/10
valence_max_img = valence_range_img[1]/10
## embeddings generation + semantic searching 
#Visuals - image search results
if image_input is not None:
    query_img = Image.open(image_input)
    st.markdown('It might take a few moments to generate results')
    with st.spinner('Generating results...'):
        model_img = load_model("clip-ViT-B-32")
        df_img, df_results_img = load_results_img(query_img)
    ## Reminder
            
    # Songs recommendation list
    st.header('Results')
    gd_img = GridOptionsBuilder.from_dataframe(df_results_img)
    gd_img.configure_selection(selection_mode='single', pre_selected_rows=[0], use_checkbox=False)
    gridoptions_img = gd_img.build()
    with st.container():
        st.subheader('Image Uploaded:')
        st.image(query_img, width=200)
        col1, col2 = st.columns([2, 1])
                
        with col1:
            st.subheader('Songs:')
            grid_table_img = AgGrid(df_results_img, height=400, width=100, gridOptions=gridoptions_img, fit_columns_on_grid_load=True,  reload_data = True, theme = 'streamlit', data_return_mode='AS_INPUT', update_mode=GridUpdateMode.SELECTION_CHANGED)
        with col2:
            st.subheader('Lyrics:')
            st.write("Credits: Genius Community")
            selected_row_img = grid_table_img["selected_rows"]
            if selected_row_img is not None:
                try:
                    #st.write(selected_row) 
                    selected_row_index_img = selected_row_img[0]['_selectedRowNodeInfo']['nodeRowIndex']
                    #st.write(selected_row_index) 
                    tuple_lyrics_results_img = df_img['lyrics_scores'].iloc[int(selected_row_index_img)]
                    #st.write(dic_lyrics_results) 
                    for result in tuple_lyrics_results_img:
                        lyrics = result[0]
                        lyrics_score = result[1] 
                        original_title_img = '<p style="font-size: {0}px;">{1} ({2})</p>'.format(str(48*float(lyrics_score)), lyrics, round(lyrics_score,3))
                        st.markdown(original_title_img, unsafe_allow_html=True)
                except:
                    #st.write('cannot fetch lyrics') 
                    pass
            else:
                st.write('')
                #st.write('no results selected')